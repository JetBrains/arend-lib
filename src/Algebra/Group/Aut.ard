\import Algebra.Group
\import Algebra.Group.AutInCat
\import Algebra.Group.Category
\import Algebra.Group.CentralizerNormalizer
\import Algebra.Group.GSet.ExampleActions
\import Algebra.Group.QuotientProperties
\import Algebra.Group.Sub
\import Algebra.Meta
\import Category
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\open Group

\func Aut_gr(G : Group) : Group => Aut-cat {GroupCat} G

\func conjugate-is-iso {G : Group} (g : G) : Iso (conjugate g) \cowith
  | hinv => conjugate (inverse g)
  | hinv_f => exts (\lam _ => unfold (unfold (rewrite (G.inverse-isInv, aux, G.inverse-left, G.ide-left, G.ide-right) idp)))
  | f_hinv => exts (\lam _ => unfold (unfold (rewrite (G.inverse-isInv, aux, G.inverse-right, G.ide-left, G.ide-right) idp)))
  \where \func aux {x y z w t : G} : x G.* (y G.* z G.* w) G.* t = (x G.* y) G.* z G.* (w G.* t) => equation

\func conjugate-commutes-with-auto {G : Group}(g : G)(f : Aut_gr G) : (Group.* {Aut_gr G}) (conjugate-is-iso g) f = (Group.* {Aut_gr G}) f (conjugate-is-iso g) => {?}


\func innerAuto-inc {G : Group} : GroupHom G (Aut_gr G) \cowith
  | func => conjugate-is-iso
  | func-ide => ext (unfold (exts (\lam _ => unfold (rewrite (G.ide-left, G.inverse_ide, G.ide-right) idp))),
                     exts \lam _ => unfold (rewrite (G.inverse_ide, G.ide-left, G.inverse_ide) G.ide-right))
  | func-* {x y : G} => Iso.equals (conjugate-is-iso (x G.* y)) (Iso.composite (conjugate-is-iso y) (conjugate-is-iso x))
      (exts \lam _ => rewrite conjAction.**-assoc idp)

\func InnerAuto[Subgroup](G : Group) : NormalSubGroup (Aut_gr G) \cowith
  | SubGroup => ImageSubGroup innerAuto-inc
  | isNormal (f : Aut_gr G) {conj-h : Aut_gr G} (p : âˆƒ(g : G) (innerAuto-inc g = conj-h)) => \case \elim  p \with {
    | inP a => inP (a.1, Iso.equals (innerAuto-inc a.1) (conjugate f conj-h)
        (exts \lam _ => (rewrite (inv a.2) {?}))) -- innerAuto-inc a.1 = conjugate f conj-h
  }

\func InnerAuto (G : Group) : Group => ImageGroup (innerAuto-inc {G})

\func conjugate-hom (G : Group) : GroupHom G (InnerAuto G) \cowith
  | func => {?}
  | func-ide => {?}
  | func-* => {?}

\func G/ZG->iso->Inn[G] (G : Group) : \Sigma (h : GroupHom (G // Center) (InnerAuto G)) h.isIsomorphism =>
  GroupFirstIsoCorollary conjugate-is-iso