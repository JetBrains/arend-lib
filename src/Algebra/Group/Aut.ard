\import Algebra.Group
\import Category
\import Paths
\import Paths.Meta

\instance Aut {A : \1-Type} (a : A) : Group (a = a)
  | ide => idp
  | * => *>
  | ide-left {x} => idp_*> x
  | ide-right => idp
  | *-assoc {x} {y} {z} => *>-assoc x y z
  | inverse => inv
  | inverse-left {x} => inv_*> x
  | inverse-right {x} => *>_inv x

-- \func equals {C : Precat} {x y : C} (e e' : Iso {C} {x} {y}) (p : e.f = e'.f) : e = e'
\instance Aut-cat {C : Precat} {c : C} : Group (Iso {C} {c} {c}) \cowith
  | ide => idIso
  | * => Iso.composite
  | ide-left {x} => Iso.equals (Iso.composite idIso x) x (rewrite C.id-right idp)
  | ide-right {x} => Iso.equals (Iso.composite x idIso) x (rewrite C.id-left idp)
  | *-assoc {x} {y} {z} => Iso.equals (Iso.composite (Iso.composite x y) z) (Iso.composite x (Iso.composite y z)) (rewrite C.o-assoc idp)
  | inverse x => inv-iso x
  | inverse-left {x : Iso {C} {c} {c}} => Iso.equals (Iso.composite (inv-iso x) x) idIso (rewrite x.f_hinv idp)
  | inverse-right {x : Iso {C} {c} {c}} => Iso.equals (Iso.composite x (inv-iso x)) idIso (rewrite x.hinv_f idp)
  \where{
    \func inv-iso (x : Iso {C} {c} {c}) : Iso {C} {c} {c} \cowith
      | f => x.hinv
      | hinv => x
      | hinv_f => x.f_hinv
      | f_hinv => x.hinv_f
  }