\import Algebra.Group
\import Algebra.Group.AutInCat
\import Algebra.Group.Category
\import Algebra.Group.GSet.ExampleActions
\import Algebra.Group.Sub
\import Algebra.Meta
\import Category
\import Function.Meta
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\open Group

\func Aut_gr(G : Group) : Group => Aut-cat {GroupCat} G

\func conjugate-is-iso {G : Group} (g : G) : Iso (conjugate g) \cowith
  | hinv => conjugate (inverse g)
  | hinv_f => exts (\lam _ => unfold (unfold (rewrite (G.inverse-isInv, aux, G.inverse-left, G.ide-left, G.ide-right) idp)))
  | f_hinv => exts (\lam _ => unfold (unfold (rewrite (G.inverse-isInv, aux, G.inverse-right, G.ide-left, G.ide-right) idp)))
  \where \func aux {x y z w t : G} : x G.* (y G.* z G.* w) G.* t = (x G.* y) G.* z G.* (w G.* t) => equation

\func conjugate-commutes-with-auto {G : Group}(g : G)(f : Aut_gr G) : (Group.* {Aut_gr G}) (conjugate-is-iso g) f = (Group.* {Aut_gr G}) f (conjugate-is-iso g) => {?}


\func innerAuto-inc {G : Group} : GroupHom G (Aut_gr G) \cowith
  | func => conjugate-is-iso
  | func-ide => ext (unfold (exts (\lam e => unfold (rewrite (G.ide-left, G.inverse_ide, G.ide-right) idp))),
                     exts \lam e => unfold (rewrite (G.inverse_ide, G.ide-left, G.inverse_ide) G.ide-right))
  | func-* {x y : G} => Iso.equals (conjugate-is-iso (x G.* y)) (Iso.composite (conjugate-is-iso y) (conjugate-is-iso x))
      (exts \lam e => rewrite conjAction.**-assoc idp)

\func InnerAuto{G : Group} : NormalSubGroup (Aut_gr G) \cowith
  | SubGroup => ImageSubGroup innerAuto-inc
  | isNormal (f : Aut_gr G) {conj-h : Aut_gr G} (p : âˆƒ(g : G) (innerAuto-inc g = conj-h)) => \case \elim  p \with {
    | inP a => inP (a.1, Iso.equals (innerAuto-inc a.1) (conjugate f conj-h)
        (exts \lam _ => (rewrite (inv a.2) {?}))) -- innerAuto-inc a.1 = conjugate f conj-h
  }\where\func aux (f h : Aut_gr G)(e : G) : h e = f e
