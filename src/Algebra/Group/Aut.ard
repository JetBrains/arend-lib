\import Algebra.Group
\import Algebra.Monoid
\import Algebra.Monoid.Category
\import Category
\import Paths
\import Paths.Meta

\instance Aut {A : \1-Type} (a : A) : Group (a = a)
  | ide => idp
  | * => *>
  | ide-left {x} => idp_*> x
  | ide-right => idp
  | *-assoc {x} {y} {z} => *>-assoc x y z
  | inverse => inv
  | inverse-left {x} => inv_*> x
  | inverse-right {x} => *>_inv x

\func End {C : Precat} (c : C) : Monoid (C.Hom c c) \cowith
  | ide => C.id c
  | * => C.âˆ˜
  | ide-left => C.id-left
  | ide-right => C.id-right
  | *-assoc => C.o-assoc

\instance Aut-cat {C : Precat} (c : C) : Group (Iso {C} {c} {c}) \cowith
  | ide => idIso
  | * => Iso.composite
  | ide-left {x} => Iso.equals (Iso.composite idIso x) x (rewrite C.id-right idp)
  | ide-right {x} => Iso.equals (Iso.composite x idIso) x (rewrite C.id-left idp)
  | *-assoc {x} {y} {z} => Iso.equals (Iso.composite (Iso.composite x y) z) (Iso.composite x (Iso.composite y z)) (rewrite C.o-assoc idp)
  | inverse x => Iso.reverse {x}
  | inverse-left {x : Iso {C} {c} {c}} => Iso.equals (Iso.composite (Iso.reverse {x}) x) idIso (rewrite x.f_hinv idp)
  | inverse-right {x : Iso {C} {c} {c}} => Iso.equals (Iso.composite x (Iso.reverse {x})) idIso (rewrite x.hinv_f idp)

\func Aut->EndInclusion {C : Precat}(c : C) : MonoidHom (Monoid.op {Aut-cat c}) (End c) \cowith
  | func (x : Iso) => x.f
  | func-ide => idp
  | func-* {x y : Iso} => idp