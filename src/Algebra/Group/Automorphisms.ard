\import Algebra.Group
\import Algebra.Group.Aut
\import Algebra.Group.Category
\import Algebra.Group.Center
\import Algebra.Group.GSet.ExampleActions
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Monoid
\import Category
\import Equiv (Equiv)
\import Function.Meta
\import Homotopy.Localization.Equiv
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set

\instance AutCat {C : Precat} (c : C) : Group (Iso {C} {c} {c}) \cowith
  | ide => idIso
  | * => Iso.composite
  | ide-left {x} => Iso.equals (Iso.composite idIso x) x (rewrite C.id-right idp)
  | ide-right {x} => Iso.equals (Iso.composite x idIso) x (rewrite C.id-left idp)
  | *-assoc {x} {y} {z} => Iso.equals (Iso.composite (Iso.composite x y) z) (Iso.composite x (Iso.composite y z)) (rewrite C.o-assoc idp)
  | inverse x => Iso.reverse {x}
  | inverse-left {x : Iso {C} {c} {c}} => Iso.equals (Iso.composite (Iso.reverse {x}) x) idIso (rewrite x.f_hinv idp)
  | inverse-right {x : Iso {C} {c} {c}} => Iso.equals (Iso.composite x (Iso.reverse {x})) idIso (rewrite x.hinv_f idp)

\func Iso_to_Aut {C : Cat}{c : C}(f : Iso {C} {c}{c}) : Aut c =>
  in0 (Equiv.ret {C.univalence {c} {c}} f)

\func Aut_to_Iso{C : Cat}{c : C}(f : Aut{C} c) : Iso {C} {c} {c} => {?}
-- Equiv.f {C.univalence {c} {c}} f

-- TODO: if it is a category with 1-Type objects => AutCat is isomorphic to Aut
-- TODO: also prove Aut_to_Iso in this case



\func End {C : Precat} (c : C) : Monoid (C.Hom c c) \cowith
  | ide => C.id c
  | * => C.âˆ˜
  | ide-left => C.id-left
  | ide-right => C.id-right
  | *-assoc => C.o-assoc

\func conjugationIsomorphism {G : Group}(g : G) : Iso {GroupCat} (conjugate g) \cowith
  | hinv => conjugate (inverse g)
  | hinv_f => exts (\lam _ => unfold (unfold (rewrite(G.inverse-isInv, aux, G.inverse-left, G.ide-left) G.ide-right)))
  | f_hinv => exts (\lam _ => unfold (unfold (rewrite(G.inverse-isInv, aux, G.inverse-right, G.ide-left) G.ide-right)))
  \where{
    \private \lemma aux {a b c d e : G} : a G.* (b G.* c G.* d) G.* e = (a G.* b) G.* c G.* (d G.* e) => equation
  }


\func InnerAutoHom (G : Group) : GroupHom G (AutCat G) \cowith
  | func => conjugationIsomorphism
  | func-ide => ext (unfold (exts (\lam _ => unfold (rewrite (G.ide-left, G.inverse_ide, G.ide-right) idp))),
                     exts \lam _ => unfold (rewrite (G.inverse_ide, G.ide-left, G.inverse_ide) G.ide-right))
  | func-* {x y : G} => Iso.equals (conjugationIsomorphism (x G.* y)) (Iso.composite (conjugationIsomorphism y) (conjugationIsomorphism x))
      (exts \lam _ => rewrite conjAction.**-assoc idp)


\func InnerAuto (G : Group) : Group => ImageGroup (InnerAutoHom G)


{- \func InnerAutoSubGroup (G : Group) : NormalSubGroup (AutCat G) \cowith
  | SubGroup => ImageSubGroup (InnerAutoHom G)
  | isNormal (g : AutCat G) {s : AutCat G} (p : âˆƒ(h : G)(conjugationIsomorphism h = s)) => {?} -}


\func CenterIsKerOfInnerAuto (G : Group) : GroupHom.Kernel {InnerAutoHom G} = Center {G} => {?}
  \where {

  }