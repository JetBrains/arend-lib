\import Algebra.Group
\import Algebra.Group.GSet.GSet
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Monoid.Sub
\import Function.Meta
\import Logic
\import Meta
\import Paths
\import Paths.Meta
\import Set

\func Center{G : Group} : NormalSubGroup G \cowith
  | contains z => \Pi(g : G) -> g * z = z * g
  | contains_ide =>\lam _ =>  rewrite (G.ide-right, G.ide-left) idp
  | contains_* {_} {_} cent1 cent2 => \lam (g : G) => rewrite (G.*-assoc, inv $ cent2 g, inv G.*-assoc, cent1 g) equation
  | contains_inverse {e} cent => \lam (g : G) =>  inv (CentralizerGr.aux e g (rewrite (inv $ cent g, G.*-assoc, G.inverse-right) G.ide-right))
  | isNormal (g : G) {h : G} p => \lam g1 => unfold (rewrite (p g, aux, G.inverse-right, G.ide-right, aux-2, G.inverse-right, G.ide-right, p g1) idp)
      \where {
        \func aux {x y z w : G} : x * (y * z * w) = (x * y) * (z * w) => equation
        \func aux-2 {x y z w : G} : x * y * z * w = x * (y * z) * w => equation
      }

\func Centralizer {M : Monoid}(S : SubSet M) : SubMonoid M \cowith
  | contains g => \Pi(s : M) -> S.contains s -> g * s = s * g
  | contains_ide => \lam (_ : M) _ => equation
  | contains_* {_ : M}{_ : M} => \lam cent1 cent2 => \lam s p => rewrite (M.*-assoc, cent2 s p, inv M.*-assoc, cent1 s p) M.*-assoc

\func CentralizerGr {G : Group}(S : SubSet G) : SubGroup G \cowith
  | SubMonoid => Centralizer {G} S
  | contains_inverse {x : G} cent => \lam s p =>  aux x s (rewrite (cent s p, G.*-assoc, G.inverse-right) G.ide-right)
      \where{
        \func aux (x : G)(s : G)  (r : x * s * inverse x = s) : inverse x * s = s * inverse x
          => {?}
      }

-- definition of Normalizer for monoids is a bit tedious and as far as i know useless

\func Normalizer {G : Group} (S : SubSet G) : SubGroup G \cowith
  | contains (g : G) => \Pi(s : G) -> S.contains s <-> S.contains (conjugate g s)
  | contains_ide => \lam (s : G) => (\lam p => transport S.contains (inv (conjugate-via-id s)) p, \lam p => transport S.contains (conjugate-via-id s) p)
  | contains_* {x : G} {y : G} norm1 norm2 => \lam (s : G) => (\lam p => {?}, {?})
  | contains_inverse => {?}

\func Centralizer<Normalizer {G : Group}(S : SubSet G){x : G} (p : SubGroup.contains {CentralizerGr S} x)
  : SubGroup.contains {Normalizer S} x => \lam (s : G) => (\lam q => transport S.contains (inv (aux s q)) q,
                                                           \lam q => {?})
\where {
  \func aux (s : G)(q : S.contains s) : conjugate x s = s => {?}
}