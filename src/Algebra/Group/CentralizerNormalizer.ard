\import Algebra.Group
\import Algebra.Group.GSet.GSet
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Monoid
\import Algebra.Monoid.Sub
\import Logic
\import Paths
\import Paths.Meta
\import Set

\func Centralizer {M : Monoid}(S : SubSet M) : SubMonoid M \cowith
  | contains g => \Pi(s : M) -> S.contains s -> g * s = s * g
  | contains_ide => \lam (_ : M) _ => equation
  | contains_* {_ : M}{_ : M} => \lam cent1 cent2 => \lam s p => rewrite (M.*-assoc, cent2 s p, inv M.*-assoc, cent1 s p) M.*-assoc

\func CentralizerGr {G : Group}(S : SubSet G) : SubGroup G \cowith
  | SubMonoid => Centralizer {G} S
  | contains_inverse {x : G} cent => \lam s p =>  aux x s (rewrite (cent s p, G.*-assoc, G.inverse-right) G.ide-right)
      \where{
        \func aux (x : G)(s : G)  (r : x * s * inverse x = s) : inverse x * s = s * inverse x
          => {?}
      }

-- definition of Normalizer for monoids is a bit tedious and as far as i know useless

\func Normalizer {G : Group} (S : SubSet G) : SubGroup G \cowith
  | contains (g : G) => \Pi(s : G) -> S.contains s <-> S.contains (conjugate g s)
  | contains_ide => \lam (s : G) => (\lam p => transport S.contains (inv (conjugate-via-id s)) p, \lam p => transport S.contains (conjugate-via-id s) p)
  | contains_* {x : G} {y : G} norm1 norm2 => \lam (s : G) => (\lam p => {?}, {?})
  | contains_inverse => {?}

\func Centralizer<Normalizer {G : Group}(S : SubSet G){x : G} (p : SubGroup.contains {CentralizerGr S} x)
  : SubGroup.contains {Normalizer S} x => \lam (s : G) => (\lam q => transport S.contains (inv (aux s q)) q,
                                                           \lam q => {?})
\where {
  \func aux (s : G)(q : S.contains s) : conjugate x s = s => {?}
}