\import Algebra.Group
\import Algebra.Meta
\import Algebra.Ordered
\import Algebra.Ring
\import Algebra.Semiring
\import Arith.Int
\import Arith.Nat
\import Data.Bool
\import Data.List
\import Data.Or
\import Function.Meta
\import Logic
\import Meta
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Prelude (neg, pos)
\open IntRing


  \func IntegralHeisenberg : Group \cowith
    | E => \Sigma Int Int Int
    | ide => (0, 0, 0)
    | * p1 q1 => \case \elim p1, \elim q1 \with {
      | (k, m, n), (k', m', n') => (k + k' + m' * n, m + m', n + n')
    }
    | ide-left {_} => ext (equation, equation, equation)
    | *-assoc {_} {_} {_} => ext (equation, equation, equation)
    | inverse p => (p.2 * p.3 - p.1, negative p.2, negative p.3)
    | inverse-left => ext (equation, equation, equation)

  -- TODO : (1) standard generating set,
  --  TODO : (2) normal form(s) in this group (in all groups as a section of projection),
  --   TODO : (3) Lower Central Series and compute it for this group
  --    TODO : (4) operations with generating sets (like realizing one in another)

  \data LargeGenSet
    | zro/zro/1
    | zro/zro/-1
    | zro/1/zro
    | zro/-1/zro
    | _1/zro/zro
    | -1/zro/zro

  \func in (a : LargeGenSet) : IntegralHeisenberg
    | zro/zro/1 => (0, 0, 1)
    | zro/zro/-1 => (0, 0, negative 1)
    | zro/1/zro => (0, 1, 0)
    | zro/-1/zro => (0, negative 1, 0)
    | _1/zro/zro => (1, 0, 0)
    | -1/zro/zro => (negative 1, 0, 0)


  \func chunks_representation (x : IntegralHeisenberg) :
    \Sigma (List LargeGenSet) (List LargeGenSet) (List LargeGenSet) => (iter_1 x.1, iter_2 x.2, iter_3 x.3)
    \where{
    \func iter_1(n : Int) : List LargeGenSet => {?}
      \func iter_2(n : Int) : List LargeGenSet => {?}
    \func iter_3(n : Int) : List LargeGenSet => {?}
  }


  \func produceRepresentative (x : IntegralHeisenberg) : List LargeGenSet => \case chunks_representation x \with {
    | (list1,list2,list3) => list1 ++ list2 ++ list3
  }