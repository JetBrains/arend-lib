\import Algebra.Group
\import Algebra.Group.Sub
\import Algebra.Monoid
\import Algebra.Monoid.Category
\import Algebra.Pointed
\import Algebra.Pointed.Category
\import Category (Cat, Precat)
\import Category.Functor
\import Category.Meta
\import Category.Subcat
\import Equiv
\import Function
\import Function.Meta
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set.Category
\import Algebra.Group.Category
\open Group


\func universal-quotient-morphism-setwise {G H : Group} (f : GroupHom G H) (N : NormalSubGroup G) (p : N <= f.Kernel)
                                          (a : N.quotient) : H \elim a
  | in~ n => f n
  | ~-equiv y x r => equality-check ((inverse (f y)) * (f x) ==< pmap (\lam y => y * (f x)) (inv f.func-inverse) >==
      f (inverse y) * (f x) ==< inv func-* >==
      f (inverse y * x) ==< lemma' f N p r >== ide `qed)
  \where
    \func lemma' {x y : G} (f : GroupHom G H) (N : NormalSubGroup G) (p : N <= f.Kernel)
                 (r : N.contains ((inverse y) * x)) : f (inverse y * x) = ide =>
      f (inverse y * x) ==< p ((inverse y) * x) r >== ide `qed

\func uqms {G H : Group} (f : GroupHom G H) (N : NormalSubGroup G) (p : N <= f.Kernel) => universal-quotient-morphism-setwise f N p

\func universal-quotient-morphism-multiplicative {G H : Group} (f : GroupHom G H) (N : NormalSubGroup G) (p : N <= f.Kernel)
                                                 (x y : N.quotient) : uqms f N p (x N.quotient.* y) = (uqms f N p x) * (uqms f N p y) \elim x, y
  | in~ a, in~ a1 => uqms f N p ((in~ a) N.quotient.* (in~ a1)) ==< idp >== uqms f N p (in~ (a * a1))
      ==< idp >== f (a * a1) ==< f.func-* >== (f a) * (f a1)
      ==< pmap ((f a)*) idp >== (f a) * uqms f N p (in~ a1)
      ==< pmap (\lam x => x * uqms f N p (in~ a1)) idp >==
      (uqms f N p (in~ a)) * (uqms f N p (in~ a1)) `qed

\func universal-quotient-morph {G H : Group} (f : GroupHom G H) (N : NormalSubGroup G)
                               (p : N <= f.Kernel) : GroupHom N.quotient H \cowith
  | func => uqms f N p
  | func-ide => uqms f N p N.quotient.ide ==< idp >== uqms f N p (in~ 1) ==< idp >== f ide ==< f.func-ide >== ide `qed
  | func-* {x y : N.quotient} => universal-quotient-morphism-multiplicative f N p x y


\func universal-quotient-property{G H : Group} (f : GroupHom G H) (N : NormalSubGroup G)
                                 (p : N <= f.Kernel) :  (universal-quotient-morph f N p) GroupCat.∘ N.quotient-map = f
  => exts (\lam (x : G) => ((universal-quotient-morph f N p) GroupCat.∘ N.quotient-map) x ==< idp >==
                  (universal-quotient-morph f N p) (N.quotient-map x) ==< idp >==
                  (universal-quotient-morph f N p) (in~ x) ==< idp >== f x `qed)

\instance ImageGroup (f : GroupHom) : Group
  | Monoid => ImageMonoid f
  | inverse a => (inverse a.1, TruncP.map a.2 \lam s => (inverse s.1, f.func-inverse *> pmap inverse s.2))
  | inverse-left => ext inverse-left
  | inverse-right => ext inverse-right


