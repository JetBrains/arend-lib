\import Algebra.Group
\import Algebra.Group.Aut
\import Algebra.Group.Category
\import Algebra.Monoid
\import Algebra.Monoid.Category
\import Category
\import Category.Functor
\import Equiv (Equiv)
\import Paths.Meta

-- TODO: when limits in presheaves are added, write that category of actions is bicomplete whenever the underlying category is bicomplete

\class MonoidCatAction {C : Precat} (M : Monoid) (\classifying  c : C){
  | act : MonoidHom M (End c)

  \func functor : Functor (DeloopM M) C \cowith
    | F => \lam _ => c
    | Func (f : M) => act f
    | Func-id => act.func-ide
    | Func-o => act.func-*
}

\instance DeloopM (M : Monoid) : Precat
  | Ob => \Sigma
  | Hom _ _ => M
  | id _ => M.ide
  | o => M.*
  | id-left => M.ide-left
  | id-right => M.ide-right
  | o-assoc => M.*-assoc

\func functor->action{C : Precat} {M : Monoid} (f : Functor (DeloopM M) C) : MonoidCatAction {C} M \cowith
  | c => f ()
  | act => \new MonoidHom {
    | func => f.Func
    | func-ide => f.Func-id
    | func-* => f.Func-o
  }

\func Action<->Functor (C : Precat)(M : Monoid) : Equiv {MonoidCatAction {C} M} {Functor (DeloopM M) C} \cowith
  | f (c : MonoidCatAction {C} M) => c.functor
  | ret (f : Functor (DeloopM M) C) => functor->action f
  | ret_f (c : MonoidCatAction {C} M) => ext (idp, idp)
  | sec (f : Functor (DeloopM M) C) => functor->action f
  | f_sec (f :  Functor (DeloopM M) C)=> idp
