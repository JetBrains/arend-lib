\import Algebra.Group
\import Algebra.Group.Category
\import Algebra.Group.GSet.GSet
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Monoid
\import Logic
\import Paths
\import Paths.Meta
\import Set

\func TranslationAction (G : Group) : TransitiveGroupAction G \cowith
  | E => G
  | ** => G.*
  | **-assoc => inv G.*-assoc
  | id-action => G.ide-left
  | trans => \lam (v v' : G) => inP (v' G.* inverse v, rewrite (G.*-assoc, G.inverse-left) G.ide-right)

\func TranslationActionOnSubsets (G : Group) : GroupAction G \cowith
  | E => SubSet G
  | ** (g : G) (p : SubSet G) => \new SubSet G {| contains h => p.contains (inverse g G.* h)}
  | **-assoc {_ : G} {_ : G} {_ : SubSet G} => ext (ext (\lam (_ : G) => rewrite (inv G.*-assoc, inv G.inverse_*) idp))
  | id-action => exts (\lam (e1 : G) => rewrite (G.inverse_ide, G.ide-left) idp)

-- action by conjugating its own elements
\func conjAction (G : Group) : GroupAction G \cowith
  | E => G
  | ** (g : G)  => conjugate g
  | **-assoc {m : G} {n : G} {e : G} : conjugate m (conjugate n e) = conjugate (m * n) e =>
  conjugate m (conjugate n e) ==< pmap (conjugate m) idp >==
  conjugate m (n * e * inverse n ) ==< idp >==
  m * (n * e * inverse n ) * inverse m ==< lemma-par >==
  (m * n) * e * (inverse n * inverse m) ==< pmap ((m * n * e) *) (inv G.inverse_*) >==
  (m * n) * e * (inverse (m * n)) ==< idp >==
  conjugate (m * n) e `qed
  | id-action {e : G} : conjugate G.ide e = e => conjugate-via-id e
  \where \lemma lemma-par {a b c d e : G} : a * (b * c * d) * e = (a * b) * c * (d * e) => equation

\func trivialAction(G : Group)(E : BaseSet) : GroupAction G E \cowith
  | ** _ e => e
  | **-assoc => idp
  | id-action => idp

\func conjugate-subset {G : Group} (g : G)(S : SubSet G) : SubSet G => \new SubSet G{| contains h => S.contains (conjugate (inverse g) h)}

\func conjSubGroupAction (G : Group) : GroupAction G \cowith
  | E => SubGroup G
  | ** (g : G) (H : SubGroup G) => \new SubGroup G {
    | SubSet => conjugate-subset g H
    | contains_ide => transport H.contains (inv (GroupHom.func-ide {conjugate (inverse g)})) H.contains_ide
    | contains_* {x} {y} p_x p_y => {?} --  transport H.contains (inv conjugate-prod) (H.contains_* {conjugate (inverse g) x} {conjugate (inverse g) y} p_x p_y)
    | contains_inverse {x} p => {?}
  }
  | **-assoc => ext (ext \lam _ => rewrite (conjAction.**-assoc, inv G.inverse_*) idp)
  | id-action => ext (ext \lam _ => rewrite (G.inverse_ide, conjugate-via-id) idp)