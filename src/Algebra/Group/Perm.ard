\import Algebra.Group.Aut
\import Arith.Nat
\import Data.Fin
\import Equiv
\import Function.Meta
\import Logic
\import Meta
\import Order.StrictOrder
\import Paths
\import Paths.Meta
\import Set
\import Set.Fin

\func SymmetricGroup (n : Nat) => Aut (Fin n)

\func cycle (X : FinSet) => \Sigma (f : X -> X) (TruncP ((Fin X.finCard, rshift) = {\Sigma (A : \Set) (A -> A)} (X, f)))
  \where {
    \func rshift {n : Nat} (x : Fin n) : Fin n \elim n
      | 0 => x
      | suc n => suc x Nat.mod suc n

    \func lshift {n : Nat} (x : Fin n) : Fin n \elim n, x
      | 0, x => x
      | suc n, 0 => n
      | suc n, suc x => x

    \lemma rshift-lshift {n : Nat} (x : Fin n) : rshift (lshift x) = x \elim n, x
      | suc n, 0 => {?}
      | suc n, suc x => {?}

    \lemma lshift-rshift {n : Nat} (x : Fin n) : lshift (rshift x) = x \elim n
      | 0 => idp
      | suc n => \case decideEq n x \with {
        | yes e => fin_nat-inj $ rewriteI e {?}
        | no q => {?} -- rewrite (mod_< ({?} : suc x < suc n)) {?}
      }

    \lemma rshift-equiv {n : Nat} : Equiv (rshift {n})
      => \new QEquiv {
        | ret => lshift
        | ret_f => {?}
        | f_sec => {?}
      }

    \lemma func-equiv (X : FinSet) (c : cycle X) : Equiv c.1 \elim c
      | (f, inP p) => \let t => sigmaEquiv _ _ _ p | s => inv (path (\lam i x => transport_pi (\lam z => z) (\lam z => z) t.1 rshift x i)) *> t.2 \in unfold at t $ {?}
  }

\type CycleDecomp (X : \Set) => \Sigma (Y : \Set) (Z : Y -> FinSet) (Equiv {X} {\Sigma (y : Y) (Z y)}) (\Pi (y : Y) -> cycle (Z y))

\func cycleDecomp_aut (X : FinSet) : Equiv {CycleDecomp X} {Aut X}
  => {?}