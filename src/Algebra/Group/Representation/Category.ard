\import Algebra.Group
\import Algebra.Group.GSet.GSet
\import Algebra.Group.Representation.Representation
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Module.LinearMap
\import Algebra.Module.Sub
\import Algebra.Monoid
\import Algebra.Monoid.Sub
\import Algebra.Pointed
\import Algebra.Ring
\import Arith.Nat
\import Category
\import Category.Meta
\import Equiv
\import Function
\import Function.Meta ($)
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Algebra.Monoid
\import Set.Category

\record InterwiningMap {R : Ring} {G : Group} (Dom : LRepres R G) (Cod : LRepres R G) {
  | \coerce func : LinearMap Dom Cod
  | func-** {e : Dom} {g : G} : func (g Dom.** e) = g Cod.** func e -- equivariance
}

-- TODO: make it a Category
\instance RepresentationCat (R : Ring) (G : Group) : Precat (LRepres R G)
  | Hom A B => InterwiningMap A B
  | id X => id-interwining X
  | o {x y z : LRepres R G} (g : InterwiningMap y z) (f : InterwiningMap x y) => \new InterwiningMap x z {
  | func => \new LinearMap{
  | func a => g (f a)
  | func-+ =>  pmap g f.func.func-+ *> g.func.func-+
  | func-*c => pmap g func-*c *> func-*c
  }
  | func-** {a : x} {h : G} =>
  g ( f (h x.** a)) ==< pmap g func-** >==
  g (h y.** f a) ==< func-** >==
  h z.** (g (f a)) `qed
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  --  | univalence => sip \lam e _ => exts \lam g x => func-** {e}
  \where \func id-interwining (X : LRepres R G) : InterwiningMap X X \cowith
  | func => \new LinearMap {
  | func a => a
  | func-+ => idp
  | func-*c => idp
  }
  | func-** => idp

\func repr+module-iso=>repr-iso {R : Ring} {G : Group} {A B : LRepres R G} {f : InterwiningMap A B} (p : Iso {LModuleCat R} f.func) : Iso f \cowith
  | hinv => inverseMap
    | hinv_f => unfold (ext {?})
    | f_hinv => aux-3
    \where{
      \func inverseMap => \new InterwiningMap B A {
        | func => p.hinv
        | func-** {b : B} {g : G} => rewrite (pmap (\lam x => p.hinv(g ** x)) (inv aux), inv f.func-**, aux-2) idp
    }
      \func aux {b : B} : f (p.hinv b) = b => path (\lam i => (p.f_hinv i) b)
      \func aux-2 {a : A} : p.hinv (f a) = a => path (\lam i => (p.hinv_f i) a)

      \func aux-3  : f âˆ˜ inverseMap = id B => {?}
    }

