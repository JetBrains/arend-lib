\import Algebra.Group
\import Algebra.Group.GSet.GSet
\import Algebra.Group.Representation.Representation
\import Algebra.Module.Category
\import Algebra.Module.LinearMap
\import Algebra.Ring
\import Category
\import Meta
\import Paths
\import Paths.Meta

\record InterwiningMap {R : Ring} {G : Group} (Dom : LRepres R G) (Cod : LRepres R G) {
  | \coerce func : LinearMap Dom Cod
  | func-** {e : Dom} {g : G} : func (g Dom.** e) = g Cod.** func e -- equivariance
}

-- TODO: make it a Category
\instance RepresentationCat (R : Ring) (G : Group) : Precat (LRepres R G)
  | Hom A B => InterwiningMap A B
  | id X => id-interwining X
  | o {x y z : LRepres R G} (g : InterwiningMap y z) (f : InterwiningMap x y) => \new InterwiningMap x z {
  | func => \new LinearMap{
  | func a => g (f a)
  | func-+ =>  pmap g f.func.func-+ *> g.func.func-+
  | func-*c => pmap g func-*c *> func-*c
  }
  | func-** {a : x} {h : G} =>
  g ( f (h x.** a)) ==< pmap g func-** >==
  g (h y.** f a) ==< func-** >==
  h z.** g (f a) `qed
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  --  | univalence => sip \lam e _ => exts \lam g x => func-** {e}
  \where \func id-interwining (X : LRepres R G) : InterwiningMap X X \cowith
  | func => \new LinearMap {
  | func a => a
  | func-+ => idp
  | func-*c => idp
  }
  | func-** => idp

\func repr+module-iso=>repr-iso {R : Ring} {G : Group} {A B : LRepres R G} {f : InterwiningMap A B} (p : Iso {LModuleCat R} f.func) : Iso f \cowith
  | hinv => inverseMap
    | hinv_f => unfold (ext (unfold (exts \lam e => aux-2)))
    | f_hinv => unfold (ext (unfold (exts \lam e => aux)))
    \where{
      \func inverseMap => \new InterwiningMap B A {
        | func => p.hinv
        | func-** {b : B} {g : G} => rewrite (inv (aux {R} {G} {A} {B} {f} {p}{b}), inv f.func-**, aux-2, aux) idp
    }
      \func aux {b : B} : f (p.hinv b) = b => path (\lam i => (p.f_hinv i) b)
      \func aux-2 {a : A} : p.hinv (f a) = a => path (\lam i => (p.hinv_f i) a)
    }

