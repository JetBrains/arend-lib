\import Algebra.Field
\import Algebra.Field.AlgebraicClosure
\import Algebra.Group
\import Algebra.Group.Category
\import Algebra.Group.Representation.Category
\import Algebra.Group.Representation.Representation
\import Algebra.Group.Representation.Sub
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Module.LinearMap
\import Algebra.Module.Sub
\import Algebra.Monoid
\import Algebra.Monoid.Sub
\import Algebra.Pointed
\import Algebra.Ring
\import Arith.Nat
\import Category
\import Equiv
\import Function.Meta ($)
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Algebra.Monoid
\import Algebra.Group.Representation.LinAlgLemmas
\open Algebra.Group.Representation.Representation


\func Irreducible {R : Ring}{G : Group} (E : LRepres R G) => \Pi(A : SubLRepres E) -> A.isTrivial

\class Hom-between-Irreducible \noclassifying {R : Ring}{G : Group} {A B : LRepres R G}(p : Irreducible A)(q : Irreducible B){
  \func Schur's-Lemma (f : InterwiningMap A B) : isZeroMap f || Iso f => \case q (ImSubRepr f) \with {
    | byLeft zero-image => byLeft (Mod:ZeroIm=>Zero-func zero-image)
    | byRight full-image => \case p (KerSubRepr f) \with {
      | byLeft zero-ker => byRight (repr+module-iso=>repr-iso (Mod:iso<->zeroKer-FullIm.2 (zero-ker, full-image)))
      | byRight full-ker => byLeft (Mod:FullKer=>Zero-func full-ker)
    }
  }
}