\import Algebra.Field
\import Algebra.Field.AlgebraicClosure
\import Algebra.Group
\import Algebra.Group.GSet.GSet
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Module.LinearMap
\import Algebra.Module.Sub
\import Algebra.Monoid
\import Algebra.Monoid.Sub
\import Algebra.Pointed
\import Algebra.Ring
\import Arith.Nat
\import Category
\import Data.List
\import Equiv
\import Function
\import Function.Meta ($)
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Algebra.Monoid
\import Set.Category

\func ZeroMod {R : Ring}(M : LModule R) => \Pi(m : M) -> m = 0

\func isZeroMap{R : Ring}{M N : LModule R}(f : LinearMap M N) => \Pi(m : M) -> f m = 0

\func Mod:AllIsKernel=>Zero-func{R : Ring}{M N : LModule R}{f : LinearMap M N}(p : isSurj (KerLModuleHom f)) : isZeroMap f => {?}

\func OneDimSubmod{R : Ring} {L : LModule R} (v : L) : SubLModule R L \cowith
  | contains u => âˆƒ(r : R)(r *c v = u)
  | contains_zro => inP(0, L.*c_zro-left)
  | contains_+ p q => \case \elim p, \elim q \with {
    | inP r1, inP r2 => inP (r1.1 + r2.1, rewrite (*c-rdistr, r1.2, r2.2) idp)
  }
  | contains_negative p => \case \elim p \with {
    | inP r => inP  (negative r.1, rewrite (L.*c_negative-left, pmap L.negative r.2) idp)
  }
  | contains_*c {a : R} {s : L} p => \case \elim p \with {
    | inP r => inP(a * r.1, rewrite (L.*c-assoc, r.2) idp)
  }


  -- iso<->inj+surj
\func GeneralLinear{R : Ring}(V : LModule R) : Group \cowith
  | E => Iso {LModuleCat R} {V} {V}
  | ide => idIso
  | * => {?}
  | ide-left => {?}
  | ide-right => {?}
  | *-assoc => {?}
  | inverse => {?}
  | inverse-left => {?}
  | inverse-right => {?}