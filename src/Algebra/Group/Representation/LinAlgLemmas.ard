\import Algebra.Group
\import Algebra.Group.AutInCat
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Module.LinearMap
\import Algebra.Module.Sub
\import Algebra.Monoid
\import Algebra.Monoid
\import Algebra.Pointed
\import Algebra.Ring
\import Category
\import Category.Functor
\import Function (isInj, isSurj)
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Set
\import Set.Category

\func ZeroMod {R : Ring}(M : LModule R) => \Pi(m : M) -> m = 0

\func isZeroMap{R : Ring}{M N : LModule R}(f : LinearMap M N) => \Pi(m : M) -> f m = 0

\func Mod:ZeroIm=>Zero-func {R : Ring}{M N : LModule R}{f : LinearMap M N}(p : ZeroMod (ImageLModule f)) : isZeroMap f
  => \lam (m : M) => rewrite (inv (aux-2 m), p (aux-1 m), LinearMap.func-zro {ImageLModuleRightHom f}) idp
      \where{
        \func aux-1 (m : M) : ImageLModule f => (f m , inP(m ,idp))
        \func aux-2 (m : M) : ImageLModuleRightHom f (aux-1 m) = f m => idp
      }

\func Mod:FullKer=>Zero-func{R : Ring}{M N : LModule R}{f : LinearMap M N}(p : isSurj (KerLModuleHom f)) : isZeroMap f
  => \lam (m : M) => \case  p m \with {
    | inP a => rewrite (inv a.2, a.1.2) idp
  }

\func Mod:zeroKer-FullIm<->inj+surj{R : Ring}{M N : LModule R}{f : LinearMap M N}:
  (\Sigma (isInj f) (isSurj f)) <-> (\Sigma (ZeroMod (KerLModule f))(isSurj (ImageLModuleRightHom f)))
  => (\lam p => (inj->zeroKer p.1, surj->FullIm p.2),
      \lam p => (zeroKer->inj p.1, FullIm->surj p.2)
     )
\where{
  \func inj->zeroKer (p : isInj f) : ZeroMod (KerLModule f) => \lam (a : KerLModule f) =>
      ext (p {a.1} {M.zro} (rewrite (a.2, f.func-zro) idp))
  \func surj->FullIm (p : isSurj f) : isSurj (ImageLModuleRightHom f) => \lam (n : N) =>
      TruncP.map (p n) \lam s => ((n, inP s), idp)
  \func zeroKer->inj (w : ZeroMod (KerLModule f)) : isInj f => \lam {a b : M} (p : f a = f b) =>
      M.fromZero (simple-lemma3 (a - b, rewrite (f.func-minus, N.toZero p ) idp) (w (a - b, rewrite (f.func-minus, N.toZero p ) idp))) -- ext (w (a - b, rewrite (f.func-minus, simple-lemma2 p ) idp))
  \func FullIm->surj (p : isSurj (ImageLModuleRightHom f)) : isSurj f => \lam (n : N) =>
  \case p n \with {
    | inP a => TruncP.map a.1.2 \lam s => (s.1, rewrite (s.2, a.2) idp)
  }
  \func simple-lemma3 (x : KerLModule f)(p : x = LModule.zro {KerLModule f}) : x.1 = LModule.zro {M} => pmap (\lam q => q.1) p
}

\lemma Mod:iso<->zeroKer-FullIm{R : Ring}{M N : LModule R}{f : LinearMap M N} :
  Iso f <-> (\Sigma (ZeroMod (KerLModule f))(isSurj (ImageLModuleRightHom f))) => <->trans LinearMap.iso<->inj+surj Mod:zeroKer-FullIm<->inj+surj


  \func OneDimSubmod{R : Ring} {L : LModule R} (v : L) : SubLModule R L \cowith
  | contains u => âˆƒ(r : R)(r *c v = u)
  | contains_zro => inP(0, L.*c_zro-left)
  | contains_+ p q => \case \elim p, \elim q \with {
    | inP r1, inP r2 => inP (r1.1 + r2.1, rewrite (*c-rdistr, r1.2, r2.2) idp)
  }
  | contains_negative p => \case \elim p \with {
    | inP r => inP  (negative r.1, rewrite (L.*c_negative-left, pmap L.negative r.2) idp)
  }
  | contains_*c {a : R} {s : L} p => \case \elim p \with {
    | inP r => inP(a * r.1, rewrite (L.*c-assoc, r.2) idp)
  }

\func GeneralLinear{R : Ring}(V : LModule R) : Group => Aut-cat {LModuleCat R} V

\func FunctorPowerLMod{R : Ring} : Functor SetCat.op (LModuleCat R) \cowith
  | F I => PowerLModule I R_m
  | Func {I} {J} (f : Hom {SetCat.op} I J) => \new LinearMap {
    | func r => \lam (j : J) => r (f j)
    | func-+ {_} {_} => ext (\lam _ => idp)
    | func-*c => ext (\lam _ => idp)
  }
  | Func-id {_} => ext (ext (\lam _ _ => unfold idp))
  | Func-o => ext (ext (\lam _ _ => unfold idp))
  \where \func R_m : LModule R => RingLModule R