\import Algebra.Group
\import Algebra.Group.Representation.Category
\import Algebra.Group.GSet.GSet
\import Algebra.Group.Representation.LinAlgLemmas
\import Algebra.Group.Representation.Representation
\import Algebra.Group.Representation.Sub
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.LinearMap
\import Algebra.Module.Sub
\import Algebra.Monoid
\import Algebra.Monoid.Sub
\import Algebra.Pointed
\import Algebra.Ring
\import Arith.Nat
\import Category
\import Equiv
\import Function
\import Function.Meta ($)
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Algebra.Monoid
\import Set.Category
\open Algebra.Group.Representation.Representation


{- | Action given as $$g \cdot \left( \sum \lambda_i x_i \right) := \sum \lambda_{g^{-1}(i)}x_i $$  for a basis of $x_i$'s -} -}
\func PermRepr {R : Ring} {G : Group} (X : GroupAction G) : LRepres R G \cowith
  | LModule => Module
  | ** g f j => f (inverse g X.** j)
  | **-assoc => ext (\lam _ => rewrite (X.**-assoc, inverse_prod) idp)
  | lin => idp
  | lin-*c => ext (\lam _ => idp)
  | id-action => ext (\lam _ => rewrite (G.inverse_ide, X.id-action) idp)
  \where{
    \func inverse_prod {m n : G} : inverse (m * n) = inverse n * inverse m =>
      inv (G.check-for-inv ( rewrite (G.*-assoc, pmap (m `*) (inv G.*-assoc) , G.inverse-right, G.ide-left, G.inverse-right) idp))
    \func R_m : LModule R => RingLModule R
    \func Module : LModule R => PowerLModule X R_m -- product module of |X| copies of R
  }

{- |
Here we prove that $span(1, 1, \ldots)$ is an invariant and non-trivial subspace in $\prod_X R$ as an $R$-module.
For this proof to work one needs to know that there are at least two points in $X$.
Also, this does not make much sense over a trivial ring, thus we eliminate this case as well.
 -}
\class PermutationRepresReducible {R : Ring} {G : Group} (X : GroupAction G) {
  | somepoint : X
  | somepoint' : X
  | different-points : somepoint /= somepoint'
  | not-trivial-ring : R.zro /= R.ide
  | decideEq-somepoint (x : X) : Dec (x = somepoint)

  -- basic definitions to work easier
  \func R_m : LModule R => RingLModule R
  \func R_m-triv : LRepres R G => TrivialAction R_m G

  \func Module : LModule R => PowerLModule X R_m -- product module of |X| copies of R
  \func Repr : LRepres R G => PermRepr {R} {G} X
  \func vectorOnes : Module => \lam _ => R.ide -- vector with coordinates (1,1,1,...)

  \func invSubMod : LinearMap R_m Module \cowith
    | func (r : R) => \lam _ => r
    | func-+ => ext (\lam _ => idp)
    | func-*c => ext (\lam _ => idp)

  \func inv-rev (r : R_m-triv)  : (invSubMod r) somepoint = r => idp

  \func aux (g : G)(r : R) : g Repr.** (invSubMod r) = (invSubMod r) => {?}

  \func invSubRepr : SubLinRepres Repr \cowith
    | S => R_m-triv
    | in => \new InterwiningMap {
      | func => invSubMod
      | func-** {e : R_m-triv}{g : G} => ext (\lam _ => rewrite (aux g e) idp)
    }
    | in-mono => \lam {a a' : R} (p : invSubMod a = invSubMod a') => rewrite (inv (inv-rev a), inv (inv-rev a'), p) idp
    \where{
      \func split->mono {A B : \Set} (m : A -> B) (r : B -> A) (p : r SetCat.âˆ˜ m = id A) : isInj m => {?}
    }


}