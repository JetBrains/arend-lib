\import Algebra.Group
\import Algebra.Group.Category
\import Algebra.Group.GSet.Category
\import Algebra.Group.GSet.GSet
\import Algebra.Group.Representation.LinAlgLemmas
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Module.LinearMap
\import Algebra.Module.Sub
\import Algebra.Monoid
\import Algebra.Monoid.Sub
\import Algebra.Pointed
\import Algebra.Ring
\import Algebra.Ring.MonoidRing
\import Arith.Nat
\import Category
\import Equiv
\import Function.Meta ($)
\import Logic
\import Logic.Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Algebra.Monoid
\import Set.Category

-- basic reference right now is https://www.uni-math.gwdg.de/tammo/rep.pdf
-- REPRESENTATION THEORY Tammo tom Dieck
-- also : https://www.maths.dur.ac.uk/users/jack.g.shotton/repthy/index.html

\class LinRepres \extends LModule, GroupAction {
  | lin {g :  G} {e e' : E} : g ** (e + e') = g ** e + g ** e'
  | lin-*c {g :  G} {e : E} {c : R} : g ** (c *c e) = c *c (g ** e)

  \func g**-zro {g : G} : g ** 0 = 0 => rewrite (inv *c_zro-right, lin-*c, *c_zro-left, *c_zro-left) idp
}

\func LRepres (R : Ring)(G : Group) : \Type => LinRepres {| R => R | G => G}

-- how to make it an instance?
\func TrivialAction (R : Ring)(E : LModule R)(G : Group) : LinRepres {| G => G} \cowith
  | LModule => E
  | GroupAction => trivialAction G E
  | lin-*c => idp
  | lin => idp

\func Repres->GL (E : LinRepres) : GroupHom E.G (GeneralLinear Space) \cowith
  | func (g : G) => pi-isIso g
  | func-ide => Iso.equals (pi-isIso G.ide) idIso (rewrite (id-image) idp)
  | func-* {x y : G} => Iso.equals (pi-isIso (x * y)) (Iso.composite (pi-isIso x) (pi-isIso y)) (rewrite (compose) {?}) -- TODO : make it work
  \where{
    \func G : Group => E.G
    \func R : Ring => E.R
    \func Space : LModule R => E
    \func pi (g : G) : LinearMap Space Space \cowith
      | func e => g ** e
      | func-+  => lin
      | func-*c => lin-*c
    \func compose {g h : G} : pi (g * h) =  (pi g) âˆ˜ {LModuleCat R} (pi h) => {?}
    \func id-image : pi G.ide = id {LModuleCat R} Space => {?}
    \func pi-isIso (g : G) : Iso {LModuleCat R}(pi g) \cowith
      | hinv => pi (inverse g)
      | hinv_f => rewrite (inv compose, G.inverse-left, id-image) idp
      | f_hinv => rewrite (inv compose, G.inverse-right, id-image) idp
  }


