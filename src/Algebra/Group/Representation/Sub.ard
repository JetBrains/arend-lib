\import Algebra.Group
\import Algebra.Group.Category
\import Algebra.Group.Representation.Category
\import Algebra.Group.Representation.Representation
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Module.LinearMap
\import Algebra.Module.Sub
\import Algebra.Monoid
\import Algebra.Monoid.Sub
\import Algebra.Pointed
\import Algebra.Ring
\import Arith.Nat
\import Data.Bool
\import Equiv
\import Function
\import Function.Meta ($)
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Algebra.Monoid
\import Algebra.Group.Representation.LinAlgLemmas
\open Algebra.Group.Representation.Representation

\class SubLinRepres {R : Ring} {G : Group} (E : LinRepres R G) (\classifying S : LinRepres R G ){
  | in : InterwiningMap S E
  | in-mono : isInj in

  \func isTrivial => ZeroMod S || isSurj in
}

\func KernelRepr{R : Ring}{G : Group}{E E' : LinRepres R G} (f : InterwiningMap E E') : LinRepres R G {| E => KerLModule f} \cowith
  | ** (g : G) (v : KerLModule f) => (g E.** v.1, rewrite (f.func-**, v.2, E'.g**-zro) idp)
  | **-assoc {g h : G} {e : KerLModule f} => {?}
  | lin => {?}
  | lin-*c => {?}


 -- TODO : make it an instance
\func KernelSubRepr {R : Ring}{G : Group}{E E' : LinRepres R G} (f : InterwiningMap E E') : SubLinRepres E \cowith
  | S => KernelRepr f
  | in => \new InterwiningMap (KernelRepr f) E {
    | func => KerLModuleHom f
    | func-** {e : KernelRepr f} {g : G} => unfold (idp)
  }
  | in-mono => \lam {a a' : KernelRepr f}(p : KerLModuleHom f a = KerLModuleHom f a') => {?}


\func ImRepr{R : Ring}{G : Group}{E E' : LinRepres R G} (f : InterwiningMap E E') : LinRepres R G {| E => ImageLModule f} \cowith
  | ** (g : G) (v : ImageLModule f) => {?}
  | **-assoc {g h : G} {e : ImageLModule f} => {?}
  | lin => {?}
  | lin-*c => {?}


-- TODO : make it an instance
\func ImSubRepr {R : Ring}{G : Group}{E E' : LinRepres R G} (f : InterwiningMap E E') : SubLinRepres E' \cowith
  | S => ImRepr f
  | in => {?}
  | in-mono => {?}