\import Algebra.Group
\import Algebra.Group.Category
\import Algebra.Group.Representation.Category
\import Algebra.Group.Representation.Representation
\import Algebra.Group.Sub
\import Algebra.Meta
\import Algebra.Module
\import Algebra.Module.Category
\import Algebra.Module.LinearMap
\import Algebra.Module.Sub
\import Algebra.Monoid
\import Algebra.Monoid.Sub
\import Algebra.Pointed
\import Algebra.Ring
\import Arith.Nat
\import Data.Bool
\import Equiv
\import Function
\import Function.Meta ($)
\import Logic
\import Logic.Meta
\import Meta
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set
\import Algebra.Monoid
\import Algebra.Group.Representation.LinAlgLemmas
\open Algebra.Group.Representation.Representation

\class SubLinRepres {R : Ring} {G : Group} (E : LRepres R G) (\classifying S : LRepres R G ){
  | in : InterwiningMap S E
  | in-mono : isInj in

  \func isTrivial => ZeroMod S || isSurj in
}

-- TODO: wtf is going on
\func KerRepr {R : Ring}{G : Group} {A B : LRepres R G}(f : InterwiningMap A B) : LRepres R G \cowith
  | LModule => KerLModule f
  | ** (g : G) (e : KerLModule f) => (g A.** e.1, rewrite (f.func-**, e.2, B.g**-zro) idp)
  | **-assoc {m n : G} {e : KerLModule f} => {?} -- (m A.** (n A.** e.1), aux-3) = ((m G.* n) A.** e.1, aux-3) => {?}
  | id-action => {?}
  | lin => {?}
  | lin-*c => {?}
  \where{
    \func aux {A : \Set} {B : A -> \Prop} (c c' : \Sigma (a : A) (B a))(p : c.1 = c'.1) : c = c' => ext p
    \func aux-2 {a : A} : \Prop => f a = 0
    \func aux-3 {m n : G} {e : KerLModule f} : f (m A.** (n A.** e.1)) = 0 => {?}
    \func aux-4 {m n : G} {e : KerLModule f} : f ((m * n) A.** e.1) = 0 => {?}
  }
