\import Algebra.Monoid
\import Algebra.Monoid.Category
\import Algebra.Monoid.Product
\import Category
\import Category.CartesianClosed
\import Category.Limit
\import Function.Meta
\import Homotopy.EckmannHilton
\import Meta
\import Paths
\import Paths.Meta


{- | Here we define monoid objects in cartesian categories.
Using Eckmann Hilton argument we prove that a monoid object in category of monoids
is necessarily a commutative monoid -}

\class MonoidOb{C : CartesianPrecat} (c : C){
  |\infix 7 m : C.Hom (Bprod c c) c
  | e : C.Hom C.terminal c
  | m-assoc : (m C.∘ (C.pair (C.proj1 {c} {C.Bprod c c}) (m C.∘ (C.proj2 {c} {C.Bprod c c})))) =
  (m C.∘ (C.pair (m C.∘ (C.proj1 {C.Bprod c c}{c})) (C.proj2 {C.Bprod c c} {c}) ) C.∘ (Iso.hinv {C.associator-iso}))
  | e-left : (m C.∘ (C.prodMap e (id c))) = (Iso.hinv {C.terminal-prod-left {c}})
  | e-right : m C.∘ (C.prodMap (id c) e) = (Iso.hinv {C.terminal-prod-left {c}}) C.∘ C.change-iso.f


  \func e-left-prod : C.Hom (Bprod C.terminal c) c => m C.∘ (C.prodMap e (id c))
  \func e-right-prod : C.Hom (Bprod c C.terminal) c => m C.∘ (C.prodMap (id c) e)
  \func left-3-prod : C.Hom (C.Bprod c (C.Bprod c c)) c => m C.∘ (C.pair (C.proj1 {c} {C.Bprod c c}) (m C.∘ (C.proj2 {c} {C.Bprod c c})))
  \func right-3-prod : C.Hom (C.Bprod c (C.Bprod c c)) c =>  m C.∘ (C.pair (m C.∘ (C.proj1 {C.Bprod c c}{c})) (C.proj2 {C.Bprod c c} {c}) ) C.∘ (Iso.hinv {C.associator-iso})
}

{- | Here we deсypher what it means for a monoid to realize a monoid object in monoid category
 - next we use it in the categorified proof. -}
\class PointSetMonoidObjectInMonoidCat(M : Monoid){
  | f : MonoidHom (ProductMonoid M M) M
  | id-left' {x : M} : f (M.ide, x) = x
  | id-right' {x : M} : f (x, M.ide) = x
  | f-assoc {x y z : M} : f (f(x, y), z) = f(x, f(y,z))

  \func EckmannHilton : Algebraic-Eckmann-Hilton M \cowith
    | o => *
    | # x y => f(x, y)
    | id_o => M.ide
    | id_o-left => M.ide-left
    | id_o-right => M.ide-right
    | id_# => M.ide
    | id_#-left => id-left'
    | id_#-right => id-right'
    | rel => inv $ f.func-*

  \func Commutative (a b : M) : a * b = b * a => EckmannHilton.comm
}


--{- | Categorified proof -}
--\func MonoidObjectInMonoidisCommutative {M : Monoid}(p : MonoidOb {MonoidBicat} M) : M.IsCommutative => DecypherDefinition.Commutative
--  \where {
--    \func DecypherDefinition : PointSetMonoidObjectInMonoidCat M => {?}
--  }