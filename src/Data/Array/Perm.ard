\import Arith.Fin
\import Combinatorics.Perm
\import Data.Fin
\import Equiv
\import Function.Meta
\import Logic
\import Logic.Meta
\import Paths

\truncated \data Perm {A : \Type} (xs ys : Array A) : \Prop \elim xs, ys
  | nil, nil => perm-nil
  | :: x xs, :: y ys => perm-:: (x = y) (Perm xs ys)
  | :: x (:: x' xs), :: y (:: y' ys) => perm-swap (x = y') (x' = y) (xs = ys)
  | xs, ys => perm-trans {zs : Array A} (Perm xs zs) (Perm zs ys)

\lemma perm-equiv {A : \Type} {xs ys : Array A} (p : Perm xs ys) : âˆƒ (e : Equiv {Fin xs.len} {Fin ys.len}) (\Pi (j : Fin xs.len) -> xs j = ys (e j)) \elim xs, ys, p
  | nil, nil, perm-nil => inP (idEquiv, \case __)
  | x :: xs, _ :: ys, perm-:: idp q => TruncP.map (perm-equiv q) $ \lam t => (transposition-generates.lift-equiv t.1, \case \elim __ \with {
    | 0 => idp
    | suc j => t.2 j
  })
  | x :: (x' :: (xs : Array)), _ :: (_ :: _), perm-swap idp idp idp => inP (transposition 0 1, \case \elim __ \with {
    | 0 => idp
    | 1 => idp
    | suc (suc j) => idp
  })
  | xs, ys, perm-trans p1 p2 => \case perm-equiv p1, perm-equiv p2 \with {
    | inP (e1,f1), inP (e2,f2) => inP (transEquiv e1 e2, \lam j => f1 j *> f2 (e1 j))
  }

\lemma equiv-perm {A : \Type} {xs ys : Array A} (e : Equiv {Fin xs.len} {Fin ys.len}) (f : \Pi (j : Fin xs.len) -> xs j = ys (e j)) : Perm xs ys
  => {?}

\lemma equiv-perm' {A : \Type} {n : Nat} {xs ys : Array A n} (e : Equiv {Fin n} {Fin n}) (f : \Pi (j : Fin n) -> xs j = ys (e j)) : Perm xs ys
  => {?}
  \where {
    \lemma transposition-perm {A : \Type} {n : Nat} {xs ys : Array A n} (a b : Fin n) (f : \Pi (j : Fin n) -> xs j = ys (transposition.transpose a b j)) : Perm xs ys \elim n, a, b
      | suc n, 0, 0 => {?}
      | suc n, 0, suc b => {?}
      | suc n, suc a, 0 => {?}
      | suc n, suc a, suc b => {?}
  }