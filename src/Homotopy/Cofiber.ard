\import Function.Meta
\import Homotopy.Pointed \using (Pointed \as HPointed)
\import Homotopy.Pushout
\import Paths
\import Paths.Meta

\func Cofiber{X Y : HPointed}(f : X ->* Y) => PushoutData (\lam (_ : X ) => ()) (\lam (x : X) => f.1 x)
  \where {
    \func cfbase{X Y : HPointed}(f : X ->* Y) : Cofiber f => pinl ()
    \func pointed{X Y : HPointed}(f : X ->* Y) : HPointed (Cofiber f) \cowith
      | base => cfbase f

    \func cfcod {X Y : HPointed}(f : X ->* Y)(y : Y) : Cofiber f => pinr y

    \func cfglue {X Y : HPointed}(f : X ->* Y)(x : X) : cfbase f = {Cofiber f} cfcod f (f.1 x) => {?} -- PushoutData.pglue x {Cofiber f}

    \func pointed-cfcod{ X Y : HPointed}(f : X ->* Y) : Y ->* Cofiber.pointed f => (cfcod f, rewrite (inv f.2, inv $ Cofiber.cfglue{_} f X.base) idp)

    --      \func to_susp {X Y : HPointed}{f : X ->* Y} : Cofiber.pointed f ->* PSusp X => (PSusp.ext-glue (\lam _ => ()) f.1, {?})
  }


--\data Cofiber {X Y : HPointed}(f : X ->* Y)
--  | cfbase : Cofiber f
--  | cfcod (y : Y) : Cofiber f
--  | cfglue (x : X) : cfbase = cfcod (f.1 x)
--  \where {
--    \func pointed{X Y : HPointed}(f : X ->* Y) : HPointed (Cofiber f) {| base => cfbase} \cowith
--
--    \func pointed-cfcod{X Y : HPointed}(f : X ->* Y) : Y ->* Cofiber.pointed f => (cfcod, rewrite (inv f.2, inv $ Cofiber.cfglue{_} X.base) idp)
--  }