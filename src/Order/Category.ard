\import Category
\import Category.Meta
\import Function ()
\import Order.Lattice
\import Order.LinearOrder
\import Order.PartialOrder
\import Order.StrictOrder
\import Paths.Meta
\import Set
\import Set.Category

\record PosetHom \extends SetHom {
  \override SetHom.Dom : Poset
  \override SetHom.Cod : Poset
  | func-<= {x y : SetHom.Dom} : x <= y -> func x <= func y
}

\instance PosetCat : Cat
  | Ob => Poset
  | Hom P1 P2 => PosetHom P1 P2
  | id P => id P
  | o f g => \new PosetHom {
    | func => f Function.o g
    | func-<= leq => func-<= (func-<= leq)
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip (\lam {_} {_} {_} p p1 => ext (ext (\lam _ _ => ext (\lam _x => func-<= {p} _x, \lam _x => func-<= {p1} _x)))) \where {
  \func id (P : Poset) => \new PosetHom P P {
    | func x => x
    | func-<= leq => leq
  }
}

\record StrictPosetHom \extends SetHom {
  \override SetHom.Dom : StrictPoset
  \override SetHom.Cod : StrictPoset
  | func-< {x y : SetHom.Dom} : x < y -> func x < func y
}

\instance StrictPosetCat : Cat
  | Ob => StrictPoset
  | Hom P1 P2 => StrictPosetHom P1 P2
  | id P => id P
  | o f g => \new StrictPosetHom {
    | func => f Function.o g
    | func-< leq => func-< (func-< leq)
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip (\lam {_} {_} {_} p p1 => ext (ext (\lam _ _ => ext (\lam _x => func-< {p} _x, \lam _x => func-< {p1} _x)))) \where {
  \func id (P : StrictPoset) => \new StrictPosetHom P P {
    | func x => x
    | func-< leq => leq
  }
}

\instance DecLinearOrderCat : Cat
  | Ob => LinearOrder.Dec
  | Hom E1 E2 => PosetHom E1 E2
  | id X => \new PosetHom X X {
    | func x => x
    | func-<= x => x
  }
  | o {X} {_} {Z} f g => \new PosetHom X Z {
    | func x => func {f} (func {g} x)
    | func-<= p1 => func-<= {f} (func-<= {g} p1)
  }
  | id-left => idp
  | id-right => idp
  | o-assoc => idp
  | univalence => sip (\lam {_} {S1} {S2} m m1 =>
      ext (ext (\lam _ _ => ext (\lam l => LinearOrder.<=_/= ((func-<= {m}) (LinearOrder.<_<= l)) (StrictPoset.<_/= l),
                                 \lam l => LinearOrder.<=_/= ((func-<= {m1}) (LinearOrder.<_<= l)) (StrictPoset.<_/= l))),
           ext (\lam _ _ => ext (\lam a => nonEqualApart (Set#.apartNotEqual a),
                                 \lam a => nonEqualApart (Set#.apartNotEqual a))),
           ext (\lam _ _ => <=-antisymmetric {S1} (func-<= {m1} (meet-univ (func-<= {m} meet-left) (func-<= {m} meet-right)))
               (meet-univ (func-<= {m1} meet-left) (func-<= {m1} meet-right))),
           ext (\lam _ _ => <=-antisymmetric {S2} (func-<= {m} (join-univ (func-<= {m1} join-left) (func-<= {m1} join-right)))
               (join-univ (func-<= {m} join-left) (func-<= {m} join-right)))))