\import Data.Bool
\import Data.Maybe
\import Data.Or

\data ConcreteExpr : \Type (\suc \lp) (\suc \lh)
  | thisExpr
  | sigmaExpr (Array (\Sigma (withVar : Bool) ConcreteExpr))
  | holeExpr
  | universeExpr (Maybe ConcreteLevel) (Maybe ConcreteLevel)
  | tupleExpr (Array ConcreteExpr)
  | classExtExpr ConcreteExpr (Array (\Sigma QName ConcreteExpr))
  | newExpr ConcreteExpr
  | evalExpr (isPEval : Bool) ConcreteExpr
  | goalExpr
  | letExpr (isHave isStrict : Bool) (Array (\Sigma AsPattern (Array ConcreteParameter) (Maybe ConcreteExpr) ConcreteExpr)) ConcreteExpr
  | piExpr ConcreteParameter ConcreteExpr
  | typedExpr ConcreteExpr ConcreteExpr
  | localVar Nat
  | globalVar QName (Maybe (Array ConcreteLevel)) (Maybe (Array ConcreteLevel))
  | caseExpr (isSCase : Bool) (Array (\Sigma (Or (\Sigma ConcreteExpr (withVar : Bool)) Nat) (Maybe ConcreteExpr))) (resultType resultTypeLevel : Maybe ConcreteExpr) (Array (\Sigma (Array AsPattern) (Maybe ConcreteExpr)))
  | projExpr ConcreteExpr Nat
  | appExpr ConcreteExpr ConcreteExpr (isExplicit : Bool)
  | lamExpr ConcreteParameter ConcreteExpr
  | boxExpr ConcreteExpr
  | numberExpr Nat
  | stringExpr String
  | qNameExpr QName
  | quoteExpr {A : \Type} A

\cons defRef (x : QName) => globalVar x nothing nothing

\meta ConcreteParameter => \Sigma (isExplicit withVar : Bool) (Maybe ConcreteExpr)

\data LevelType | pLevel | hLevel

\data ConcreteLevel
  | stdLevel LevelType
  | maxLevel ConcreteLevel ConcreteLevel
  | sucLevel ConcreteLevel
  | numberLevel Int
  | infLevel
  | varLevel Nat LevelType

\data Pattern : \Type (\suc \lp) (\suc \lh)
  | tuplePattern (Array AsPattern)
  | namePattern (withVar : Bool) (Maybe ConcreteExpr)
  | numberPattern Int
  | conPattern QName (Array AsPattern)

\meta AsPattern => \Sigma Pattern (Maybe (Maybe ConcreteExpr))

\func appsExpr (e : ConcreteExpr) (l : Array (\Sigma ConcreteExpr Bool)) : ConcreteExpr \elim l
  | nil => e
  | a :: l => appsExpr (appExpr e a.1 a.2) l
