\import Data.Bool
\import Data.Maybe
\import Meta
\import Reflect.ConcreteExpr
\import Reflect.Error
\import Reflect.Meta

\data IO (A : \Type)
  | \private io ConcreteExpr

\private \func unIO {A : \Type} (m : IO A) : ConcreteExpr
  | io e => e

\meta doIO {A : \Type} (m : IO A) => typecheck (unIO m)

\meta runIO {A : \Type} (m : IO A) => run {
  args <- Reflect.Meta.getArgs,
  type <- Reflect.Meta.getExpectedType,
  Reflect.Meta.pushObject "runIO:args" args,
  Reflect.Meta.pushObject "runIO:type" type,
  res <- doIO m,
  _ <- Reflect.Meta.popObject "runIO:type",
  _ <- Reflect.Meta.popObject "runIO:args",
  res
}

\func return {A : \Type} (a : A) : IO A
  => io (reflect (\lam (c : A -> _) => c a))

\func \infixl 1 >>= {A B : \Type} (m : IO A) (k : A -> IO B) : IO (\suc \lp) (\suc \lh) B \elim m
  | io e => io (reflect (\lam (c : B -> _) => splice e (\lam a => doIO (k a) c)))

\func getArgs : IO (Array (\Sigma ConcreteExpr Bool))
  => io (reflect (Reflect.Meta.peekObject "runIO:args" "'getArgs' must be invoked within 'runIO'"))

\func getExpectedType : IO (Maybe ConcreteExpr)
  => io (reflect (Reflect.Meta.peekObject "runIO:type" "'getExpectedType' must be invoked within 'runIO'"))

\func abort {A : \Type} (e : ConcreteExpr) : IO A
  => io (reflect (\lam (_ : A -> _) => splice e))

\func error {A : \Type} (msg : Error) : IO A
  => abort (reflect (Reflect.Meta.error msg))

\func Unit => \Sigma

\func pushObject (id : String) (e : ConcreteExpr) : IO Unit
  => io (reflect (\lam (c : \Sigma -> _) => Reflect.Meta.pushObject id (splice e) (c ())))

\func popObject (id : String) : IO ConcreteExpr
  => io (reflect (\lam (c : ConcreteExpr -> _) => Reflect.Meta.popObject id "" (\lam o => c (reflect o))))

\func peekObject (id : String) : IO ConcreteExpr
  => io (reflect (\lam (c : ConcreteExpr -> _) => Reflect.Meta.peekObject id "" (\lam o => c (reflect o))))