\import Data.Bool
\import Meta
\import Reflect.ConcreteExpr
\import Reflect.Meta

\data IO (A : \Type)
  | \private io ConcreteExpr

\private \func unIO {A : \Type} (m : IO A) : ConcreteExpr
  | io e => e

\meta doIO {A : \Type} (m : IO A) => typecheck (unIO m)

\meta runIO {A : \Type} (m : IO A) => run {
  args <- Reflect.Meta.getArgs,
  Reflect.Meta.pushObject "runIO" args,
  res <- doIO m,
  _ <- Reflect.Meta.popObject "runIO",
  res
}

\func return {A : \Type} (a : A) : IO A
  => io (reflect (\lam (c : A -> _) => c a))

\func \infixl 1 >>= {A B : \Type} (m : IO A) (k : A -> IO B) : IO (\suc \lp) (\suc \lh) B \elim m
  | io e => io (reflect (\lam c => splice e (\lam a => doIO (k a) c)))

\func getArgs : IO (Array (\Sigma ConcreteExpr Bool))
  => io (reflect (Reflect.Meta.peekObject "runIO" "'getArgs' must be invoked within 'runIO'"))

\func abort {A : \Type} (e : ConcreteExpr) : IO A
  => io (reflect (\lam _ => splice e))

\func error {A : \Type} (msg : String) : IO A
  => abort (reflect (Reflect.Meta.error msg))
