\import Data.Bool
\import Data.Maybe
\import Data.Or
\import Function
\import Reflect.ConcreteExpr
\import Reflect.Meta

\lemma lamTest : reflect (\lam (x : Nat) => x) = lamExpr (true, "x", just $ defRef ``Nat) (localVar 0) => idp

\lemma lamTest2 : reflect (\lam {x : Nat} => x) = lamExpr (false, "x", just $ defRef ``Nat) (localVar 0) => idp

\lemma lamTest3 : reflect (\lam _ x => x) = lamExpr (true, "", nothing) (lamExpr (true, "x", nothing) (localVar 0)) => idp

\lemma piTest : reflect (\Pi {x : Nat} -> x = x) = piExpr (false, "x", just $ defRef ``Nat) (appExpr (appExpr (defRef ``=) (localVar 0) true) (localVar 0) true) => idp

\lemma piTest2 (A : \Type) : reflect (\Pi (x y : A) -> x = y) = piExpr (true, "x", just $ localVar 0) (piExpr (true, "y", just $ localVar 1) $ appExpr (appExpr (defRef ``=) (localVar 1) true) (localVar 0) true) => idp

\lemma numberTest : reflect 7 = numberExpr 7 => idp

\lemma stringTest : reflect "foo" = stringExpr "foo" => idp

\lemma qnameTest : reflect ``Nat = qNameExpr ``Nat => idp

\lemma boxTest {A : \Prop} (a : A) : reflect (\box a) = boxExpr (localVar 0) => idp

\lemma levelTest : reflect (\Set \lp) = universeExpr (just (stdLevel pLevel)) (just (numberLevel 0)) => idp

\lemma levelTest2 \plevels p1 >= p2 : reflect (\Set p1) = universeExpr (just (varLevel 0 pLevel)) (just (numberLevel 0)) => idp

\lemma levelTest3 \plevels p1 >= p2 : reflect (\Set p2) = universeExpr (just (varLevel 1 pLevel)) (just (numberLevel 0)) => idp

\lemma levelTest4 \hlevels h1 <= h2 : reflect (\Type 0 h2) = universeExpr (just (numberLevel 0)) (just (varLevel 1 hLevel)) => idp

\lemma universeTest : reflect \Set = universeExpr nothing (just (numberLevel 0)) => idp

\lemma universeTest2 : reflect \Type0 = universeExpr (just (numberLevel 0)) nothing => idp

\lemma universeTest3 : reflect \Prop = universeExpr (just (numberLevel 0)) (just (numberLevel -1)) => idp

\lemma tupleTest : reflect (3,7) = tupleExpr (numberExpr 3 :: numberExpr 7 :: nil) => idp

\lemma projTest (p : \Sigma Nat Nat) : reflect p.1 = projExpr (localVar 0) 0 => idp

\lemma projTest2 (p : \Sigma Nat Nat) : reflect p.3 = projExpr (localVar 0) 2 => idp

\lemma appTest : reflect (3 {4} 5) = appExpr (appExpr (numberExpr 3) (numberExpr 4) false) (numberExpr 5) true => idp

\lemma sigmaTest : reflect (\Sigma (x : Nat) (x = x)) = sigmaExpr (("x", defRef ``Nat) :: ("", appExpr (appExpr (defRef ``=) (localVar 0) true) (localVar 0) true) :: nil) => idp

\lemma sigmaTest2 (A : \Type) : reflect (\Sigma (x y : A) (x = y)) = sigmaExpr (("x", localVar 0) :: ("y", localVar 1) :: ("", appExpr (appExpr (defRef ``=) (localVar 1) true) (localVar 0) true) :: nil) => idp

\lemma caseTest (x y : Nat) : reflect (\case x, y \with { | 0, _ => 3 | _, suc y => y | x, _ => x }) =
                                caseExpr false ((inl (localVar 1, ""), nothing) :: (inl (localVar 0, ""), nothing) :: nil) nothing nothing (
                                ((numberPattern 0, "", nothing) :: (namePattern "" nothing, "", nothing) :: nil, just $ numberExpr 3) ::
                                ((namePattern "" nothing, "", nothing) :: (conPattern ``suc ((namePattern "y" nothing, "", nothing) :: nil), "", nothing) :: nil, just $ localVar 0) ::
                                ((namePattern "x" nothing, "", nothing) :: (namePattern "" nothing, "", nothing) :: nil, just $ localVar 0) :: nil)
                               => idp

\lemma caseTest2 (x : Nat) : reflect (\scase \elim x \with { | 0 => idp | suc _ => idp }) = caseExpr true ((inr (localVar 0), nothing) :: nil) nothing nothing (
                              ((numberPattern 0, "", nothing) :: nil, just $ defRef ``idp) ::
                              ((conPattern ``suc ((namePattern "" nothing, "", nothing) :: nil), "", nothing) :: nil, just $ defRef ``idp) :: nil)
                            => idp

\lemma caseTest3 (x : Nat) : reflect (\case x \as x \return x = x \with { | 0 => idp | suc _ => idp }) =
                              caseExpr false ((inl (localVar 0, "x"), nothing) :: nil) (just $ appExpr (appExpr (defRef ``=) (localVar 0) true) (localVar 0) true) nothing (
                                ((numberPattern 0, "", nothing) :: nil, just $ defRef ``idp) ::
                                ((conPattern ``suc ((namePattern "" nothing, "", nothing) :: nil), "", nothing) :: nil, just $ defRef ``idp) :: nil)
                             => idp

\lemma caseTest4 (b : Bool) : reflect (\case b \as x, idp : b = x \with { | true, p => inl p | false, p => inr p }) =
                                caseExpr false ((inl (localVar 0, "x"), nothing) :: (inl (defRef ``idp, ""), just (appExpr (appExpr (defRef ``=) (localVar 1) true) (localVar 0) true)) :: nil) nothing nothing (
                                  ((conPattern ``true nil, "", nothing) :: (namePattern "p" nothing, "", nothing) :: nil, just $ appExpr (defRef ``inl) (localVar 0) true) ::
                                  ((conPattern ``false nil, "", nothing) :: (namePattern "p" nothing, "", nothing) :: nil, just $ appExpr (defRef ``inr) (localVar 0) true) :: nil)
                               => idp

\lemma caseTest5 (x : Int) : reflect (\case x \with { | -1 => 0 | x => x }) =
                              caseExpr false ((inl (localVar 0, ""), nothing) :: nil) nothing nothing (
                                ((numberPattern -1, "", nothing) :: nil, just $ numberExpr 0) ::
                                ((namePattern "x" nothing, "", nothing) :: nil, just $ localVar 0) :: nil)
                              => idp

\lemma caseTest6 (x : Nat) : reflect (\case x \with { | 0 => 0 | suc z \as y => y }) =
                              caseExpr false ((inl (localVar 0, ""), nothing) :: nil) nothing nothing (
                                ((numberPattern 0, "", nothing) :: nil, just $ numberExpr 0) ::
                                ((conPattern ``suc ((namePattern "z" nothing, "", nothing) :: nil), "y", nothing) :: nil, just $ localVar 0) :: nil)
                              => idp

\lemma typedTest (x : Nat) : reflect ((x, idp) : \Sigma (x : Nat) (x = x)) = typedExpr (tupleExpr (localVar 0 :: defRef ``idp :: nil)) (sigmaExpr $ ("x", defRef ``Nat) :: ("", appExpr (appExpr (defRef ``=) (localVar 0) true) (localVar 0) true) :: nil) => idp

\lemma holeTest (x : Nat) : reflect (x = {_} x) = appExpr (appExpr (appExpr (defRef ``=) holeExpr false) (localVar 0) true) (localVar 0) true => idp

\lemma thisTest : reflect \this = thisExpr => idp

\lemma evalTest : reflect (\eval foo) = evalExpr false (defRef ``foo) => idp
  \where
    \sfunc foo => 0

\lemma pevalTest : reflect (\peval evalTest.foo) = evalExpr true (defRef ``evalTest.foo) => idp

\func classExtTest : reflect (R { | x => 3 | y => 7 }) = classExtExpr (defRef ``R) ((``R.x, numberExpr 3) :: (``R.y, numberExpr 7) :: nil) => idp
  \where
    \record R (x y z : Nat)

\lemma newTest : reflect (\new classExtTest.R 3 7) = newExpr (appExpr (appExpr (defRef ``classExtTest.R) (numberExpr 3) true) (numberExpr 7) true) => idp

\lemma letTest : reflect (\let f x y => x Nat.+ y | g (z : Nat) : Nat => f z z | w => g 3 \in f (g w) 7) =
  letExpr false false (
    ((namePattern "f" nothing, "", nothing), (true, "x", nothing) :: (true, "y", nothing) :: nil, nothing, appExpr (appExpr (defRef ``Nat.+) (localVar 1) true) (localVar 0) true) ::
    ((namePattern "g" nothing, "", nothing), (true, "z", just $ defRef ``Nat) :: nil, just $ defRef ``Nat, appExpr (appExpr (localVar 1) (localVar 0) true) (localVar 0) true) ::
    ((namePattern "w" nothing, "", nothing), nil, nothing, appExpr (localVar 0) (numberExpr 3) true) ::
  nil) (appExpr (appExpr (localVar 2) (appExpr (localVar 1) (localVar 0) true) true) (numberExpr 7) true)
  => idp

\lemma letTest2 : reflect (\let x => 3 | p : x = 3 => idp \in p) =
  letExpr false false (
    ((namePattern "x" nothing, "", nothing), nil, nothing, numberExpr 3) ::
    ((namePattern "p" nothing, "", nothing), nil, just $ appExpr (appExpr (defRef ``=) (localVar 0) true) (numberExpr 3) true, defRef ``idp) ::
  nil) (localVar 0)
  => idp

\func quoteTest {A : \Type} (a : A) : reflect (quote a) = quoteExpr a => idp

\func spliceTest (e : ConcreteExpr) : reflect (splice e) = e => idp