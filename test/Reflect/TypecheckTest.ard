\import Data.Array
\import Data.Bool
\import Data.Maybe
\import Data.Or
\import Function
\import Meta
\import Reflect.ConcreteExpr
\import Reflect.Meta

\lemma lamTest : typecheck (lamExpr (true, true, just $ defRef ``Nat) (localVar 0)) = (\lam (x : Nat) => x) => idp

\lemma lamTest2 : typecheck (lamExpr (false, true, just $ defRef ``Nat) (localVar 0)) = (\lam {x : Nat} => x) => idp

\lemma lamTest3 : typecheck (lamExpr (true, true, just $ defRef ``Nat) $ lamExpr (true, true, just $ defRef ``Nat) (localVar 0)) = (\lam (x y : Nat) => y) => idp

\lemma lamTest4 : typecheck (lamExpr (true, true, just $ defRef ``Nat) $ lamExpr (true, true, just $ defRef ``Nat) (localVar 1)) = (\lam (x y : Nat) => x) => idp

\lemma piTest : typecheck (piExpr (false, true, just $ defRef ``Nat) (appExpr (appExpr (defRef ``=) (localVar 0) true) (localVar 0) true)) = (\Pi {x : Nat} -> x = x) => idp

\func piTest2 (A : \Type) : typecheck (piExpr (true, true, just $ localVar 0) (piExpr (true, true, just $ localVar 1) $ appExpr (appExpr (defRef ``=) (localVar 1) true) (localVar 0) true)) = (\Pi (x y : A) -> x = y) => idp

\lemma numberTest : typecheck (numberExpr 7) = 7 => idp

\lemma stringTest : typecheck (stringExpr "foo") = "foo" => idp

\lemma qnameTest : typecheck (qNameExpr ``Nat) = ``Nat => idp

\lemma boxTest {A : \Prop} (a : A) : typecheck (boxExpr (localVar 0)) = \box a => idp

\func levelTest : typecheck (universeExpr (just (stdLevel pLevel)) (just (numberLevel 0))) = (\Set \lp) => idp

\func levelTest2 \plevels p1 >= p2 : typecheck (universeExpr (just (varLevel 0 pLevel)) (just (numberLevel 0))) = (\Set p1) => idp

\func levelTest3 \plevels p1 >= p2 : typecheck (universeExpr (just (varLevel 1 pLevel)) (just (numberLevel 0))) = (\Set p2) => idp

\func levelTest4 \hlevels h1 <= h2 => fails (idp : typecheck (universeExpr (varLevel 1 hLevel) (numberLevel 0)) = (\Type 0 h2))

\func levelTest5 \hlevels h1 <= h2 : typecheck (universeExpr (just (numberLevel 0)) (just (varLevel 1 hLevel))) = (\Type 0 h2) => idp

\func universeTest : typecheck (universeExpr nothing (just (numberLevel 0))) = \Set => idp

\func universeTest2 : typecheck (universeExpr (just (numberLevel 0)) nothing) = \Type0 => idp

\lemma tupleTest : typecheck (tupleExpr $ numberExpr 3 :: numberExpr 7 :: nil) = (3,7) => idp

\lemma projTest (p : \Sigma Nat Nat) : typecheck (projExpr (localVar 0) 0) = p.1 => idp

\lemma projTest2 (p : \Sigma Nat Nat) : typecheck (projExpr (localVar 0) 1) = p.2 => idp

\lemma projTest3 (p : \Sigma Nat Nat) => fails $ typecheck (projExpr (localVar 0) 2)

\func sigmaTest : typecheck (sigmaExpr $ (true, defRef ``Nat) :: (false, appExpr (appExpr (defRef ``=) (localVar 0) true) (localVar 0) true) :: nil) = (\Sigma (x : Nat) (x = x)) => idp

\func sigmaTest2 (A : \Type) : typecheck (sigmaExpr ((true, localVar 0) :: (true, localVar 1) :: (false, appExpr (appExpr (defRef ``=) (localVar 1) true) (localVar 0) true) :: nil)) = (\Sigma (x y : A) (x = y)) => idp

\func sigmaTest3 => fails $ typecheck $ sigmaExpr $ (false, defRef ``Nat) :: (false, appExpr (appExpr (defRef ``=) (localVar 0) true) (localVar 0) true) :: nil

\lemma caseTest (x y : Nat) : typecheck (caseExpr true ((inl (localVar 1, false), nothing) :: (inl (localVar 0, false), nothing) :: nil) nothing nothing $
                                          (conPattern ``zero nil :: namePattern false nothing :: nil, just $ numberExpr 3) ::
                                          (namePattern false nothing :: conPattern ``suc (namePattern true nothing :: nil) :: nil, just $ localVar 0) ::
                                          (namePattern true nothing :: namePattern false nothing :: nil, just $ localVar 0) :: nil) =
                                        (\case x, y \with { | 0, _ => 3 | _, suc y => y | x, _ => x }) => idp

\lemma caseTest2 (x : Nat) : typecheck (caseExpr true ((inr 0, nothing) :: nil) nothing nothing $
                                        (conPattern ``zero nil :: nil, just $ defRef ``idp) ::
                                        (conPattern ``suc (namePattern false nothing :: nil) :: nil, just $ defRef ``idp) :: nil) = {x = x}
                                       (\case \elim x \with { | 0 => idp | suc _ => idp }) => idp

\lemma caseTest3 (x : Nat) : typecheck (caseExpr true ((inl (localVar 0, true), nothing) :: nil) (just $ appExpr (appExpr (defRef ``=) (localVar 0) true) (localVar 0) true) nothing $
                                        (conPattern ``zero nil :: nil, just $ defRef ``idp) ::
                                        (conPattern ``suc (namePattern false nothing :: nil) :: nil, just $ defRef ``idp) :: nil) =
                                       (\case x \as x \return x = x \with { | 0 => idp | suc _ => idp }) => idp

\lemma caseTest4 (b : Bool) : typecheck (caseExpr true ((inl (localVar 0, true), nothing) :: (inl (defRef ``idp, false), just (appExpr (appExpr (defRef ``=) (localVar 1) true) (localVar 0) true)) :: nil) nothing nothing $
                                          (conPattern ``true nil :: namePattern true nothing :: nil, just $ appExpr (defRef ``inl) (localVar 0) true) ::
                                          (conPattern ``false nil :: namePattern true nothing :: nil, just $ appExpr (defRef ``inr) (localVar 0) true) :: nil) = {Or (b = true) (b = false)}
                                        (\case b \as x, idp : b = x \with { | true, p => inl p | false, p => inr p }) => idp

\lemma typedTest (x : Nat) : typecheck (typedExpr (tupleExpr (localVar 0 :: defRef ``idp :: nil)) $ sigmaExpr $ (true, defRef ``Nat) :: (false, appExpr (appExpr (defRef ``=) (localVar 0) true) (localVar 0) true) :: nil) = ((x, idp) : \Sigma (x : Nat) (x = x)) => idp

\lemma holeTest (x : Nat) : typecheck (appExpr (appExpr (appExpr (defRef ``=) holeExpr false) (localVar 0) true) (localVar 0) true) = (x = x) => idp

\record R (x : Nat) {
  \func thisTest => fails (typecheck (appExpr (defRef ``x) (localVar 0) false))

  \func thisTest2 : typecheck (appExpr (defRef ``x) thisExpr false) = x => idp
}

\lemma evalTest : typecheck (evalExpr false $ defRef ``foo) = \eval foo => idp
  \where
    \sfunc foo => 0

\lemma pevalTest : typecheck (evalExpr true $ defRef ``evalTest.foo) = \peval evalTest.foo => idp

\func classExtTest : typecheck (classExtExpr (defRef ``R) $ (``R.x, numberExpr 3) :: (``R.y, numberExpr 7) :: nil) = R 3 7  => idp
  \where
    \record R (x y z : Nat)

\lemma newTest : typecheck (newExpr $ classExtExpr (defRef ``R) $ (``R.x, numberExpr 3) :: (``R.y, numberExpr 7) :: nil) = \new R 3 7  => idp
  \where
    \record R (x y : Nat)

\lemma letTest : typecheck (letExpr false false (
                      (namePattern true nothing, (true, true, nothing) :: (true, true, nothing) :: nil, nothing, appExpr (appExpr (defRef ``Nat.+) (localVar 1) true) (localVar 0) true) ::
                      (namePattern true nothing, (true, true, just $ defRef ``Nat) :: nil, just $ defRef ``Nat, appExpr (appExpr (localVar 1) (localVar 0) true) (localVar 0) true) ::
                      (namePattern true nothing, nil, nothing, appExpr (localVar 0) (numberExpr 3) true) ::
                      nil) $ appExpr (appExpr (localVar 2) (appExpr (localVar 1) (localVar 0) true) true) (numberExpr 7) true) =
                  (\let f x y => x Nat.+ y | g (z : Nat) : Nat => f z z | w => g 3 \in f (g w) 7) => idp

\lemma letTest2 : typecheck (letExpr false false (
                    (namePattern true nothing, nil, nothing, numberExpr 3) ::
                    (namePattern true nothing, nil, just $ appExpr (appExpr (defRef ``=) (localVar 0) true) (numberExpr 3) true, defRef ``idp) ::
                    nil) (localVar 0)) = (\let x => 3 | p : x = 3 => idp \in p) => idp

\lemma haveTest => fails $ typecheck $ letExpr true false (namePattern true nothing) (
                    (namePattern true nothing, nil, nothing, numberExpr 3) ::
                    (namePattern true nothing, nil, just $ appExpr (appExpr (defRef ``=) (localVar 0) true) (numberExpr 3) true, defRef ``idp) ::
                    nil) (numberExpr 0)

\lemma quoteTest : typecheck (tupleExpr $ map (\lam t => quoteExpr t.1) $ (3,5) :: (7,2) :: (4,6) :: nil) = (3,7,4) => idp
